{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Westworld \u00b6 Photo by Alexander London on Unsplash Description \u00b6 Westworld is a multi-agent simulation library, its goal to simulate and optimize systems and environments with multiple agents interacting. Its inspiration is drawn from Unity software and Unity ML Agents , adapted in Python. The goal is to be able to simulate environments in logistics, retail, epidemiology, providing pre-coded spatial environments and communication between agents. Optimization can be included using heuristics as well as Reinforcement Learning. Experimental This library is extremely experimental, under active development and alpha-release Don't expect the documentation to be up-to-date or all features to be tested Please contact us if you have any question The name is of course inspired by the TV series Westworld, which is actually a gigantic multi-agent simulation system. Quickstart \u00b6 Let's model an ecosystem of rabbits looking and competing for food from westworld.environment import GridEnvironment from westworld.agents import BaseAgent from westworld.objects import BaseCollectible from westworld.simulation import Simulation from westworld.colors import * class Food ( BaseCollectible ): pass class Rabbit ( BaseAgent ): def __init__ ( self , x , y , curiosity = 5 ): super () . __init__ ( x , y , color = ( 229 , 229 , 229 ), curiosity = curiosity ) def step ( self ): # Find closest food targets = self . find_closest ( name = \"Food\" , k = 1 ) # If there is still food, move towards the food if len ( targets ) > 0 : target = targets [ 0 ] # Use naive pathfinding for faster computation as there is no obstacle self . move_towards ( obj = target , naive = True ) # Otherwise just wandering # Changing direction every n steps where n = curiosity else : self . wander () food_spawner = lambda x , y : Food ( x , y , color = ( 220 , 150 , 50 ), img_asset = \"ball\" ) rabbit_spawner = lambda x , y : Rabbit ( x , y , curiosity = 5 ) # Setup environment env = GridEnvironment ( 20 , 10 , 20 , show_grid = True , background_color = ( 102 , 178 , 102 ), grid_color = ( 127 , 191 , 127 ), toroidal = True ) env . spawn ( rabbit_spawner , 3 ) env . spawn ( food_spawner , 20 ) env . render () # Make simulation sim = Simulation ( env , fps = 10 , name = \"Quickstart\" ) _ , _ = sim . run_episode ( n_steps = 50 , save = True , replay = True , save_format = \"gif\" ,) Features \u00b6 Current features \u00b6 Easy creation of Grid and non-grid environments Objects (Agents, Obstacles, Collectibles, Triggers) Subclassing of different objects to create custom objects Spawner to generate objects randomly in the environment Basic rigid body system for all objects Simple agent behaviors (pathfinding, wandering, random walk, fleeing, vision range) Automatic maze generation Layer integration to convert image to obstacle and snap it to a grid Sample simulations and sample agents for classic simulations Simulation visualization, replay and export (gif or video) Roadmap features \u00b6 More classic simulations and tutorials (boids, sugarscape) Better pathfinding Easy Reinforcement Learning integration with Stable Baselines Other visualization functions than PyGame for web integration Installation \u00b6 Install from PyPi \u00b6 The library is available on PyPi via pip install westworld For developers \u00b6 You can clone the github repo / fork and develop locally Poetry is used for environment management, dependencies and publishing, after clone you can run # To setup the environment poetry install # To run Jupyter notebook or a python console poetry run jupyter notebook poetry run python Contributors \u00b6 Th\u00e9o Alves Da Costa Javascript version \u00b6 A javascript version is being developed at https://github.com/TheoLvs/westworldjs","title":"Home"},{"location":"#westworld","text":"Photo by Alexander London on Unsplash","title":"Westworld"},{"location":"#description","text":"Westworld is a multi-agent simulation library, its goal to simulate and optimize systems and environments with multiple agents interacting. Its inspiration is drawn from Unity software and Unity ML Agents , adapted in Python. The goal is to be able to simulate environments in logistics, retail, epidemiology, providing pre-coded spatial environments and communication between agents. Optimization can be included using heuristics as well as Reinforcement Learning. Experimental This library is extremely experimental, under active development and alpha-release Don't expect the documentation to be up-to-date or all features to be tested Please contact us if you have any question The name is of course inspired by the TV series Westworld, which is actually a gigantic multi-agent simulation system.","title":"Description"},{"location":"#quickstart","text":"Let's model an ecosystem of rabbits looking and competing for food from westworld.environment import GridEnvironment from westworld.agents import BaseAgent from westworld.objects import BaseCollectible from westworld.simulation import Simulation from westworld.colors import * class Food ( BaseCollectible ): pass class Rabbit ( BaseAgent ): def __init__ ( self , x , y , curiosity = 5 ): super () . __init__ ( x , y , color = ( 229 , 229 , 229 ), curiosity = curiosity ) def step ( self ): # Find closest food targets = self . find_closest ( name = \"Food\" , k = 1 ) # If there is still food, move towards the food if len ( targets ) > 0 : target = targets [ 0 ] # Use naive pathfinding for faster computation as there is no obstacle self . move_towards ( obj = target , naive = True ) # Otherwise just wandering # Changing direction every n steps where n = curiosity else : self . wander () food_spawner = lambda x , y : Food ( x , y , color = ( 220 , 150 , 50 ), img_asset = \"ball\" ) rabbit_spawner = lambda x , y : Rabbit ( x , y , curiosity = 5 ) # Setup environment env = GridEnvironment ( 20 , 10 , 20 , show_grid = True , background_color = ( 102 , 178 , 102 ), grid_color = ( 127 , 191 , 127 ), toroidal = True ) env . spawn ( rabbit_spawner , 3 ) env . spawn ( food_spawner , 20 ) env . render () # Make simulation sim = Simulation ( env , fps = 10 , name = \"Quickstart\" ) _ , _ = sim . run_episode ( n_steps = 50 , save = True , replay = True , save_format = \"gif\" ,)","title":"Quickstart"},{"location":"#features","text":"","title":"Features"},{"location":"#current-features","text":"Easy creation of Grid and non-grid environments Objects (Agents, Obstacles, Collectibles, Triggers) Subclassing of different objects to create custom objects Spawner to generate objects randomly in the environment Basic rigid body system for all objects Simple agent behaviors (pathfinding, wandering, random walk, fleeing, vision range) Automatic maze generation Layer integration to convert image to obstacle and snap it to a grid Sample simulations and sample agents for classic simulations Simulation visualization, replay and export (gif or video)","title":"Current features"},{"location":"#roadmap-features","text":"More classic simulations and tutorials (boids, sugarscape) Better pathfinding Easy Reinforcement Learning integration with Stable Baselines Other visualization functions than PyGame for web integration","title":"Roadmap features"},{"location":"#installation","text":"","title":"Installation"},{"location":"#install-from-pypi","text":"The library is available on PyPi via pip install westworld","title":"Install from PyPi"},{"location":"#for-developers","text":"You can clone the github repo / fork and develop locally Poetry is used for environment management, dependencies and publishing, after clone you can run # To setup the environment poetry install # To run Jupyter notebook or a python console poetry run jupyter notebook poetry run python","title":"For developers"},{"location":"#contributors","text":"Th\u00e9o Alves Da Costa","title":"Contributors"},{"location":"#javascript-version","text":"A javascript version is being developed at https://github.com/TheoLvs/westworldjs","title":"Javascript version"},{"location":"references/","text":"References \u00b6 Pathfinding \u00b6 Articles \u00b6 Pathfinding detailed walkthrough and course - and many other resources by Amit Patel A* walkthrough by Patrick Lester Easy A* pathfinding by Nicolas Swift and improvements by Ryan Collinwood Pathfinding explained in Python Complete wikipedia page Software alternatives \u00b6 Unity NetLogo and the models library MESA - Python SPADE - Python abcEconomics GAMA-Platform Manim by the great Grant Sanderson / 3Blue1Browwn","title":"References"},{"location":"references/#references","text":"","title":"References"},{"location":"references/#pathfinding","text":"","title":"Pathfinding"},{"location":"references/#articles","text":"Pathfinding detailed walkthrough and course - and many other resources by Amit Patel A* walkthrough by Patrick Lester Easy A* pathfinding by Nicolas Swift and improvements by Ryan Collinwood Pathfinding explained in Python Complete wikipedia page","title":"Articles"},{"location":"references/#software-alternatives","text":"Unity NetLogo and the models library MESA - Python SPADE - Python abcEconomics GAMA-Platform Manim by the great Grant Sanderson / 3Blue1Browwn","title":"Software alternatives"},{"location":"api/","text":"API \u00b6 WIP","title":"API"},{"location":"api/#api","text":"WIP","title":"API"},{"location":"tutorials/maze/","text":"","title":"Maze generation"},{"location":"tutorials/movements/","text":"Movements \u00b6 For each step in the simulation, the environment will calculate what happens to every non-stationary objects binded to it. In particular, the agents who will probably move between t and t+1. If you can subclass the step() function for any custom movements. There are already many pre-coded functions to make your agent move. We will need the basic westworld imports for this tutorial from westworld.environment import GridEnvironment from westworld.agents import BaseAgent from westworld.simulation import Simulation from westworld.colors import BLUE , GREEN , RED Random Walk \u00b6 The most simple move there is: taking a random step. As you can see, you simply subclass the BaseAgent , setup a random walk in one line of code and add it to the environment class Agent ( BaseAgent ): def step ( self ): self . random_walk () # Define all agents agent1 = Agent ( 2 , 3 , curiosity = 5 , color = GREEN ) agent2 = Agent ( 17 , 7 , curiosity = 2 , color = BLUE ) agent3 = Agent ( 8 , 1 , curiosity = 20 , color = RED ) # Define environment env = GridEnvironment ( width = 20 , height = 10 , cell_size = 20 , show_grid = True ) # Add agents to the environment env . add_object ([ agent1 , agent2 , agent3 ]) env . render () # Make simulation sim = Simulation ( env , fps = 10 , name = \"RandomWalk\" ) _ , _ = sim . run_episode ( n_steps = 20 , save = True , replay = True , save_format = \"gif\" ) Wandering \u00b6 If you need an agent to explore the environment, you can use the .wander() function. Basically the agent will walk straight in a direction, and change direction at some point using a curiosity factor - ie for curiosity = 5 it will change direction every 5 steps (in the example below, compare the behavior of the 3 agents with a different curiosity). In a GridEnvironment , the direction angle is approximated by sampling horizontal and vertical movements on the grid to match the angle as best as possible. class Agent ( BaseAgent ): def step ( self ): self . wander () Pathfinding \u00b6 Another useful behavior is moving towards a point. This is done using pathfinding algorithms. If there are some obstacles, you may require advanced pathfinding (tutorial to come) which is more expensive to compute. Without obstacles you can use naive pathfinding. Just use the .move_towards() function and your agents will move towards a given target class Agent ( BaseAgent ): def step ( self ): self . move_towards ( 0 , 0 , naive = True )","title":"Movements"},{"location":"tutorials/movements/#movements","text":"For each step in the simulation, the environment will calculate what happens to every non-stationary objects binded to it. In particular, the agents who will probably move between t and t+1. If you can subclass the step() function for any custom movements. There are already many pre-coded functions to make your agent move. We will need the basic westworld imports for this tutorial from westworld.environment import GridEnvironment from westworld.agents import BaseAgent from westworld.simulation import Simulation from westworld.colors import BLUE , GREEN , RED","title":"Movements"},{"location":"tutorials/movements/#random-walk","text":"The most simple move there is: taking a random step. As you can see, you simply subclass the BaseAgent , setup a random walk in one line of code and add it to the environment class Agent ( BaseAgent ): def step ( self ): self . random_walk () # Define all agents agent1 = Agent ( 2 , 3 , curiosity = 5 , color = GREEN ) agent2 = Agent ( 17 , 7 , curiosity = 2 , color = BLUE ) agent3 = Agent ( 8 , 1 , curiosity = 20 , color = RED ) # Define environment env = GridEnvironment ( width = 20 , height = 10 , cell_size = 20 , show_grid = True ) # Add agents to the environment env . add_object ([ agent1 , agent2 , agent3 ]) env . render () # Make simulation sim = Simulation ( env , fps = 10 , name = \"RandomWalk\" ) _ , _ = sim . run_episode ( n_steps = 20 , save = True , replay = True , save_format = \"gif\" )","title":"Random Walk"},{"location":"tutorials/movements/#wandering","text":"If you need an agent to explore the environment, you can use the .wander() function. Basically the agent will walk straight in a direction, and change direction at some point using a curiosity factor - ie for curiosity = 5 it will change direction every 5 steps (in the example below, compare the behavior of the 3 agents with a different curiosity). In a GridEnvironment , the direction angle is approximated by sampling horizontal and vertical movements on the grid to match the angle as best as possible. class Agent ( BaseAgent ): def step ( self ): self . wander ()","title":"Wandering"},{"location":"tutorials/movements/#pathfinding","text":"Another useful behavior is moving towards a point. This is done using pathfinding algorithms. If there are some obstacles, you may require advanced pathfinding (tutorial to come) which is more expensive to compute. Without obstacles you can use naive pathfinding. Just use the .move_towards() function and your agents will move towards a given target class Agent ( BaseAgent ): def step ( self ): self . move_towards ( 0 , 0 , naive = True )","title":"Pathfinding"},{"location":"tutorials/objects/","text":"Objects \u00b6 Understanding the different objects in Westworld WIP Agents \u00b6 Obstacles \u00b6 Triggers \u00b6 Collectibles \u00b6 Creating multiple objects with the spawner \u00b6 Layers \u00b6","title":"Objects"},{"location":"tutorials/objects/#objects","text":"Understanding the different objects in Westworld WIP","title":"Objects"},{"location":"tutorials/objects/#agents","text":"","title":"Agents"},{"location":"tutorials/objects/#obstacles","text":"","title":"Obstacles"},{"location":"tutorials/objects/#triggers","text":"","title":"Triggers"},{"location":"tutorials/objects/#collectibles","text":"","title":"Collectibles"},{"location":"tutorials/objects/#creating-multiple-objects-with-the-spawner","text":"","title":"Creating multiple objects with the spawner"},{"location":"tutorials/objects/#layers","text":"","title":"Layers"},{"location":"tutorials/other/","text":"","title":"Other"},{"location":"tutorials/quickstart/","text":"Quickstart \u00b6 Getting started with westworld in a few lines of code - Westworld is multi-agent simulation library in Python. You can use it to simulate spatial environments with agents moving, interacting with each other, finding their path and avoiding obstacles, ... In this quickstart, we will create a super simple ecosystem of rabbits competing and looking for food and eating them when they find it. Preparing the basic imports \u00b6 We will import necessary objects classes, the environment and simulation wrappers. from westworld.environment import GridEnvironment from westworld.agents import BaseAgent from westworld.objects import BaseCollectible from westworld.simulation import Simulation Defining the food to collect \u00b6 Objects that are collected by agents and then disappear are called Collectibles . They can trigger something once an agent collects them and then are destroyed. We will then subclass this Collectible class to create our Food object. class Food ( BaseCollectible ): pass Yes this class does nothing. For now. Actually we will just use the name of the class Food in the Rabbit behavior function to look for those collectibles. Of course we could add more features to this collectible, for example increase the life of the rabbit once eaten. Defining the rabbits \u00b6 We will then define a rabbit whose behavior will be described in a .step() function - ie everything that happens between t and t+1 Looking for the closest food piece using helper function .find_closest() (we will use the class name here to find for the Food objects) If it finds any, the rabbit will move towards the object to collect it using .move_towards() helper function until collecting it and going to the next closest If there aren't anymore food, the rabbit will just .wander() around the environment class Rabbit ( BaseAgent ): def __init__ ( self , x , y ): super () . __init__ ( x , y , color = ( 229 , 229 , 229 ), curiosity = 5 ) def step ( self ): # Find closest food targets = self . find_closest ( name = \"Food\" , k = 1 ) # If there is still food, move towards the food if len ( targets ) > 0 : target = targets [ 0 ] # Use naive pathfinding for faster computation as there is no obstacle self . move_towards ( obj = target , naive = True ) # Otherwise just wandering # Changing direction every n steps where n = curiosity else : self . wander () Preparing spawners \u00b6 Spawners will help us add multiple rabbits and food pieces at the same time, it's a generator of custom objects in your environment. We will simply use a lambda function: rabbit_spawner = lambda x,y : Rabbit(x,y) food_spawner = lambda x,y : Food(x,y,color = (220,150,50),img_asset = \"ball\") For the Food object we use default arguments of BaseCollectible objects to change the food color and shape (make it look like a ball). Defining the environment \u00b6 Now we need to put those food and rabbits somewhere, let's create a grid environment. There are many arguments to define width, height, cell size, colors, etc... env = GridEnvironment ( 20 , 10 , 20 , show_grid = True , background_color = ( 102 , 178 , 102 ), grid_color = ( 127 , 191 , 127 ), toroidal = True ) We now add a few rabbits and food pieces using the spawner. env . spawn ( rabbit_spawner , 3 ) env . spawn ( food_spawner , 20 ) And we initalize the environment and visualize it using .render() function env . render () Launching the simulation \u00b6 Next step is to simulate what happens in the environment with the step rules that we defined. We now wrap the environment in a Simulation object and run an episode of 50 steps. We save the simulation to a gif to be visualized. sim = Simulation ( env , fps = 10 , name = \"Quickstart\" ) _ , _ = sim . run_episode ( n_steps = 50 , save = True , replay = True , save_format = \"gif\" ,) We get the following simulation: Going further \u00b6 There are so many behaviors you can customize using precoded functions in westworld or write your own, you can add obstacles, put the agents in a maze, define other agents, complexify agent behavior, log information over time. You are not even obliged to use a grid environment and can work in a continuous environment. For this ecosystem simulation, there are also many improvements you can do: add rabbit reproduction, short sightedness, introduce predators or different type of food. We will see a more complex example in another tutorial.","title":"Quickstart"},{"location":"tutorials/quickstart/#quickstart","text":"Getting started with westworld in a few lines of code - Westworld is multi-agent simulation library in Python. You can use it to simulate spatial environments with agents moving, interacting with each other, finding their path and avoiding obstacles, ... In this quickstart, we will create a super simple ecosystem of rabbits competing and looking for food and eating them when they find it.","title":"Quickstart"},{"location":"tutorials/quickstart/#preparing-the-basic-imports","text":"We will import necessary objects classes, the environment and simulation wrappers. from westworld.environment import GridEnvironment from westworld.agents import BaseAgent from westworld.objects import BaseCollectible from westworld.simulation import Simulation","title":"Preparing the basic imports"},{"location":"tutorials/quickstart/#defining-the-food-to-collect","text":"Objects that are collected by agents and then disappear are called Collectibles . They can trigger something once an agent collects them and then are destroyed. We will then subclass this Collectible class to create our Food object. class Food ( BaseCollectible ): pass Yes this class does nothing. For now. Actually we will just use the name of the class Food in the Rabbit behavior function to look for those collectibles. Of course we could add more features to this collectible, for example increase the life of the rabbit once eaten.","title":"Defining the food to collect"},{"location":"tutorials/quickstart/#defining-the-rabbits","text":"We will then define a rabbit whose behavior will be described in a .step() function - ie everything that happens between t and t+1 Looking for the closest food piece using helper function .find_closest() (we will use the class name here to find for the Food objects) If it finds any, the rabbit will move towards the object to collect it using .move_towards() helper function until collecting it and going to the next closest If there aren't anymore food, the rabbit will just .wander() around the environment class Rabbit ( BaseAgent ): def __init__ ( self , x , y ): super () . __init__ ( x , y , color = ( 229 , 229 , 229 ), curiosity = 5 ) def step ( self ): # Find closest food targets = self . find_closest ( name = \"Food\" , k = 1 ) # If there is still food, move towards the food if len ( targets ) > 0 : target = targets [ 0 ] # Use naive pathfinding for faster computation as there is no obstacle self . move_towards ( obj = target , naive = True ) # Otherwise just wandering # Changing direction every n steps where n = curiosity else : self . wander ()","title":"Defining the rabbits"},{"location":"tutorials/quickstart/#preparing-spawners","text":"Spawners will help us add multiple rabbits and food pieces at the same time, it's a generator of custom objects in your environment. We will simply use a lambda function: rabbit_spawner = lambda x,y : Rabbit(x,y) food_spawner = lambda x,y : Food(x,y,color = (220,150,50),img_asset = \"ball\") For the Food object we use default arguments of BaseCollectible objects to change the food color and shape (make it look like a ball).","title":"Preparing spawners"},{"location":"tutorials/quickstart/#defining-the-environment","text":"Now we need to put those food and rabbits somewhere, let's create a grid environment. There are many arguments to define width, height, cell size, colors, etc... env = GridEnvironment ( 20 , 10 , 20 , show_grid = True , background_color = ( 102 , 178 , 102 ), grid_color = ( 127 , 191 , 127 ), toroidal = True ) We now add a few rabbits and food pieces using the spawner. env . spawn ( rabbit_spawner , 3 ) env . spawn ( food_spawner , 20 ) And we initalize the environment and visualize it using .render() function env . render ()","title":"Defining the environment"},{"location":"tutorials/quickstart/#launching-the-simulation","text":"Next step is to simulate what happens in the environment with the step rules that we defined. We now wrap the environment in a Simulation object and run an episode of 50 steps. We save the simulation to a gif to be visualized. sim = Simulation ( env , fps = 10 , name = \"Quickstart\" ) _ , _ = sim . run_episode ( n_steps = 50 , save = True , replay = True , save_format = \"gif\" ,) We get the following simulation:","title":"Launching the simulation"},{"location":"tutorials/quickstart/#going-further","text":"There are so many behaviors you can customize using precoded functions in westworld or write your own, you can add obstacles, put the agents in a maze, define other agents, complexify agent behavior, log information over time. You are not even obliged to use a grid environment and can work in a continuous environment. For this ecosystem simulation, there are also many improvements you can do: add rabbit reproduction, short sightedness, introduce predators or different type of food. We will see a more complex example in another tutorial.","title":"Going further"},{"location":"tutorials/simple_pathfinding/","text":"Simple pathfinding \u00b6 Abstract In this page, a few examples of simulations to experiment with pathfinding Simple pathfinding \u00b6 In this simulation - All agents are moving towards the same point - When we left click we add an object - When we right click we change the point of attraction Python code for this simulation import time import pygame import numpy as np from westworld.environment.grid import GridEnvironment from westworld.agents.grid import GridAgent , Obstacle , Trigger from westworld.simulation.simulation import Simulation BOX_SIZE = 5 LOOKAHEAD = 15 target = ( 0 , 0 ) #----------------------------------------------------------- # DEFINING CLASSES #----------------------------------------------------------- class Agent ( GridAgent ): target = target def step ( self , env ): self . move_towards ( x = self . target [ 0 ], y = self . target [ 1 ], env = env , n = LOOKAHEAD ) class LargeSimulation ( Simulation ): def on_event ( self , event ): # If left click we add an obstacle if self . event_is_click ( event ): x , y = self . get_mouse_pos () obstacle = obstacle_spawner ( x , y ) env . add_object ( obstacle ) # If right click we change the direction for pathfinding if self . event_is_rightclick ( event ): new_target = self . get_mouse_pos () for agent in self . env . agents : agent . target = new_target #----------------------------------------------------------- # DEFINING SIMULATION #----------------------------------------------------------- # Prepare spawners and agent_spawner = lambda x , y : Agent ( x , y , 1 , 1 , BOX_SIZE ) obstacle_spawner = lambda x , y : Obstacle ( x , y , 5 , 5 , BOX_SIZE ,( 0 , 200 , 100 )) # Setup grid env = GridEnvironment ( BOX_SIZE , 200 , 100 ) env . spawn ( agent_spawner , 100 ) # Setup simulation sim = LargeSimulation ( env , fps = 25 ) sim . run_episode ( n_steps = 250 , save = True ) Clicking to add obstacles \u00b6 With more points \u00b6 Simulation when running is still slow, but replay is at a normal 25 FPS Simple Pathfinding with zones \u00b6 In this second example : - All agents are moving towards a different target point chosen randomly Python code for this simulation import time import pygame import numpy as np import random from westworld.environment.grid import GridEnvironment from westworld.agents.grid import GridAgent , Obstacle , Trigger from westworld.simulation.simulation import Simulation BOX_SIZE = 5 LOOKAHEAD = 15 WIDTH = 100 HEIGHT = 100 N_ZONES = 10 TARGETS = list ( zip ( np . random . randint ( 0 , WIDTH , N_ZONES ), np . random . randint ( 0 , HEIGHT , N_ZONES ))) #----------------------------------------------------------- # DEFINING SIMULATION #----------------------------------------------------------- class Agent ( GridAgent ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . target = random . choice ( TARGETS ) def step ( self , env ): self . move_towards ( x = self . target [ 0 ], y = self . target [ 1 ], env = env , n = LOOKAHEAD ) class PathfindingSimulationZones ( Simulation ): pass #----------------------------------------------------------- # DEFINING CLASSES #----------------------------------------------------------- # Setup spawners agent_spawner = lambda x , y : Agent ( x , y , 1 , 1 , BOX_SIZE ) # Setup grid env = GridEnvironment ( BOX_SIZE , WIDTH , HEIGHT ) env . spawn ( agent_spawner , 300 ) # Setup simulation sim = PathfindingSimulationZones ( env , fps = 25 ) sim . run_episode ( n_steps = 250 , save = True )","title":"Simple pathfinding"},{"location":"tutorials/simple_pathfinding/#simple-pathfinding","text":"Abstract In this page, a few examples of simulations to experiment with pathfinding","title":"Simple pathfinding"},{"location":"tutorials/simple_pathfinding/#simple-pathfinding_1","text":"In this simulation - All agents are moving towards the same point - When we left click we add an object - When we right click we change the point of attraction Python code for this simulation import time import pygame import numpy as np from westworld.environment.grid import GridEnvironment from westworld.agents.grid import GridAgent , Obstacle , Trigger from westworld.simulation.simulation import Simulation BOX_SIZE = 5 LOOKAHEAD = 15 target = ( 0 , 0 ) #----------------------------------------------------------- # DEFINING CLASSES #----------------------------------------------------------- class Agent ( GridAgent ): target = target def step ( self , env ): self . move_towards ( x = self . target [ 0 ], y = self . target [ 1 ], env = env , n = LOOKAHEAD ) class LargeSimulation ( Simulation ): def on_event ( self , event ): # If left click we add an obstacle if self . event_is_click ( event ): x , y = self . get_mouse_pos () obstacle = obstacle_spawner ( x , y ) env . add_object ( obstacle ) # If right click we change the direction for pathfinding if self . event_is_rightclick ( event ): new_target = self . get_mouse_pos () for agent in self . env . agents : agent . target = new_target #----------------------------------------------------------- # DEFINING SIMULATION #----------------------------------------------------------- # Prepare spawners and agent_spawner = lambda x , y : Agent ( x , y , 1 , 1 , BOX_SIZE ) obstacle_spawner = lambda x , y : Obstacle ( x , y , 5 , 5 , BOX_SIZE ,( 0 , 200 , 100 )) # Setup grid env = GridEnvironment ( BOX_SIZE , 200 , 100 ) env . spawn ( agent_spawner , 100 ) # Setup simulation sim = LargeSimulation ( env , fps = 25 ) sim . run_episode ( n_steps = 250 , save = True )","title":"Simple pathfinding"},{"location":"tutorials/simple_pathfinding/#clicking-to-add-obstacles","text":"","title":"Clicking to add obstacles"},{"location":"tutorials/simple_pathfinding/#with-more-points","text":"Simulation when running is still slow, but replay is at a normal 25 FPS","title":"With more points"},{"location":"tutorials/simple_pathfinding/#simple-pathfinding-with-zones","text":"In this second example : - All agents are moving towards a different target point chosen randomly Python code for this simulation import time import pygame import numpy as np import random from westworld.environment.grid import GridEnvironment from westworld.agents.grid import GridAgent , Obstacle , Trigger from westworld.simulation.simulation import Simulation BOX_SIZE = 5 LOOKAHEAD = 15 WIDTH = 100 HEIGHT = 100 N_ZONES = 10 TARGETS = list ( zip ( np . random . randint ( 0 , WIDTH , N_ZONES ), np . random . randint ( 0 , HEIGHT , N_ZONES ))) #----------------------------------------------------------- # DEFINING SIMULATION #----------------------------------------------------------- class Agent ( GridAgent ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . target = random . choice ( TARGETS ) def step ( self , env ): self . move_towards ( x = self . target [ 0 ], y = self . target [ 1 ], env = env , n = LOOKAHEAD ) class PathfindingSimulationZones ( Simulation ): pass #----------------------------------------------------------- # DEFINING CLASSES #----------------------------------------------------------- # Setup spawners agent_spawner = lambda x , y : Agent ( x , y , 1 , 1 , BOX_SIZE ) # Setup grid env = GridEnvironment ( BOX_SIZE , WIDTH , HEIGHT ) env . spawn ( agent_spawner , 300 ) # Setup simulation sim = PathfindingSimulationZones ( env , fps = 25 ) sim . run_episode ( n_steps = 250 , save = True )","title":"Simple Pathfinding with zones"},{"location":"tutorials/simple_visionrange/","text":"Simple Vision Range simulation \u00b6 Abstract For many simulations we need to find objects in range Simple Range \u00b6 In this simulation agents in range turn red.","title":"Simple Vision Range simulation"},{"location":"tutorials/simple_visionrange/#simple-vision-range-simulation","text":"Abstract For many simulations we need to find objects in range","title":"Simple Vision Range simulation"},{"location":"tutorials/simple_visionrange/#simple-range","text":"In this simulation agents in range turn red.","title":"Simple Range"}]}